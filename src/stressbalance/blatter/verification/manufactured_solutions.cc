// DO NOT EDIT. This code was generated by a Python script.
#include <cmath>

#include "manufactured_solutions.hh"

namespace pism {

Vector2 blatter_xy_exact(double x, double y)
{
  double x0 = exp(x);
  double x1 = 2*M_PI*y;
  return {
    x0*sin(x1),
    x0*cos(x1)
  };
}

Vector2 blatter_xy_source(double x, double y, double B)
{
  double x0 = 2*M_PI*y;
  double x1 = cos(x0);
  double x2 = pow(x1, 2);
  double x3 = pow(M_PI, 2);
  double x4 = pow(M_PI, 3);
  double x5 = pow(M_PI, 4);
  double x6 = sin(x0);
  double x7 = pow(x6, 2);
  double x8 = pow(2, 2.0/3.0)*B*exp((1.0/3.0)*x)/pow(x2*(4*x3 + 1 + 4*M_PI) + x7*(16*x3 - 8*M_PI + 4), 4.0/3.0);
  return {
    -1.0/3.0*x6*x8*(x2*(6*x3 + 20*x4 + 72*x5 - 2 + 3*M_PI) + x7*(-48*x3 + 32*x4 + 96*x5 - 8 + 36*M_PI)),
    -1.0/6.0*x1*x8*(x2*(-12*x3 + 136*x4 + 192*x5 - 18*M_PI - 1) + x7*(96*x3 - 128*x4 + 384*x5 - 24*M_PI - 4))
  };
}

Vector2 blatter_xz_exact(double x, double z, double A, double rho, double g, double s_0, double alpha, double H, double beta) {

  return {
    -4*A*pow(alpha, 3)*pow(g, 3)*pow(rho, 3)*pow(x, 3)*(-pow(H, 4) + pow(-alpha*pow(x, 2) + s_0 - z, 4)) + 2*H*alpha*g*rho*x/beta,
    0.0
  };
}

Vector2 blatter_xz_source(double x, double z, double A, double rho, double g, double s_0, double alpha, double H, double beta) {
  double phi_1 = alpha*pow(x, 2) - s_0 + z;
  double phi_2 = 4*A*pow(alpha, 3)*pow(g, 3)*pow(rho, 3)*x;
  double phi_3 = 4*pow(phi_1, 5)*pow(phi_2, 2)*pow(x, 3);
  double phi_4 = -2*H*alpha*g*rho/beta + 8*alpha*pow(phi_1, 3)*phi_2*pow(x, 3) + 3*phi_2*x*(-pow(H, 4) + pow(phi_1, 4));
  double phi_5 = 48*pow(alpha, 2)*pow(phi_1, 2)*phi_2*pow(x, 4) + 56*alpha*pow(phi_1, 3)*phi_2*pow(x, 2) + 6*phi_2*(-pow(H, 4) + pow(phi_1, 4));
  double mu = (1.0/2.0)/cbrt(A*phi_1*phi_3*x + A*pow(phi_4, 2));

  return {
    (16.0/3.0)*A*pow(mu, 4)*(-6*pow(phi_1, 3)*phi_2*phi_3*pow(x, 3) - 18*pow(phi_1, 2)*phi_2*pow(phi_4, 2)*pow(x, 2) - 6*phi_1*phi_3*phi_5*x + 24*phi_3*phi_4*(2*alpha*pow(x, 2) + phi_1) - 2*pow(phi_4, 2)*phi_5),
    0.0
  };
}

Vector2 blatter_xz_source_bed(double x, double z, double A, double rho, double g, double s_0, double alpha, double H, double beta) {
  double phi_1 = alpha*pow(x, 2) - s_0 + z;
  double phi_2 = 4*A*pow(alpha, 3)*pow(g, 3)*pow(rho, 3)*x;
  double phi_3 = 4*pow(phi_1, 5)*pow(phi_2, 2)*pow(x, 3);
  double phi_4 = -2*H*alpha*g*rho/beta + 8*alpha*pow(phi_1, 3)*phi_2*pow(x, 3) + 3*phi_2*x*(-pow(H, 4) + pow(phi_1, 4));
  double mu = (1.0/2.0)/cbrt(A*phi_1*phi_3*x + A*pow(phi_4, 2));
  double n_x = -2*alpha*x/sqrt(4*pow(alpha, 2)*pow(x, 2) + 1);
  double n_z = -1/sqrt(4*pow(alpha, 2)*pow(x, 2) + 1);

  return {
    2*H*alpha*g*rho*x - beta*phi_2*pow(x, 2)*(-pow(H, 4) + pow(phi_1, 4)) - 4*mu*n_x*phi_4 - 4*mu*n_z*pow(phi_1, 3)*phi_2*pow(x, 2),
    0.0
  };
}

Vector2 blatter_xz_source_surface(double x, double z, double A, double rho, double g, double s_0, double alpha, double H, double beta) {
  double phi_1 = alpha*pow(x, 2) - s_0 + z;
  double phi_2 = 4*A*pow(alpha, 3)*pow(g, 3)*pow(rho, 3)*x;
  double phi_3 = 4*pow(phi_1, 5)*pow(phi_2, 2)*pow(x, 3);
  double phi_4 = -2*H*alpha*g*rho/beta + 8*alpha*pow(phi_1, 3)*phi_2*pow(x, 3) + 3*phi_2*x*(-pow(H, 4) + pow(phi_1, 4));
  double mu = (1.0/2.0)/cbrt(A*phi_1*phi_3*x + A*pow(phi_4, 2));
  double n_x = 2*alpha*x/sqrt(4*pow(alpha, 2)*pow(x, 2) + 1);
  double n_z = pow(4*pow(alpha, 2)*pow(x, 2) + 1, -1.0/2.0);

  return {
    -4*mu*n_x*phi_4 - 4*mu*n_z*pow(phi_1, 3)*phi_2*pow(x, 2),
    0.0
  };
}

Vector2 blatter_xz_cfbc_exact(double x, double z, double B, double L, double rho_i, double rho_w)
{
  return {
    (1.0/2.0)*L*g*z*(rho_i - rho_w)*sin(M_PI*x/L)/(M_PI*B),
    0
  };
}

Vector2 blatter_xz_cfbc_source(double x, double z, double B, double L, double rho_i, double rho_w)
{
  double x0 = M_PI/L;
  return {
    -g*x0*z*(rho_i - rho_w)*sin(x*x0),
    0
  };
}

Vector2 blatter_xz_cfbc_surface(double x, double z, double B, double L, double rho_i, double rho_w)
{
  return {
    (1.0/4.0)*L*g*(rho_i - rho_w)*sin(M_PI*x/L)/M_PI,
    0
  };
}

Vector2 blatter_xz_cfbc_base(double x, double z, double B, double L, double rho_i, double rho_w)
{
  return {
    -1.0/4.0*L*g*(rho_i - rho_w)*sin(M_PI*x/L)/M_PI,
    0
  };
}

} // end of namespace pism
